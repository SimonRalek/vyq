const std = @import("std");
const shared = @import("shared.zig");
const debug = @import("debug.zig");
const Allocator = std.mem.Allocator;

const _value = @import("value.zig");
const Val = _value.Val;
const Function = _value.Object.Function;
const ResultError = shared.ResultError;
const Reporter = @import("reporter.zig");
const _scanner = @import("scanner.zig");
const Scanner = _scanner.Scanner;
const Location = _scanner.Location;
const Parser = @import("parser.zig").Parser;
const Token = @import("token.zig").Token;
const Block = @import("block.zig").Block;
const VM = @import("virtualmachine.zig").VirtualMachine;
const Local = @import("storage.zig").Local;

const localArray = std.ArrayList(Local);

pub const Emitter = struct {
    const Self = @This();

    allocator: Allocator,
    vm: *VM,
    parser: ?Parser = null,
    reporter: *Reporter,

    wrapped: ?*Emitter,

    locals: localArray,
    scope_depth: i16,

    function: *Function,

    /// Inicializace Emitteru
    pub fn init(allocator: Allocator, vm: *VM, emitter: ?*Self) Self {
        var locals = localArray.init(vm.allocator);

        locals.append(.{
            .depth = 0,
            .name = "",
            .is_const = false,
        }) catch {};

        return .{
            .allocator = allocator,
            .vm = vm,
            .reporter = vm.reporter,
            .locals = locals,
            .scope_depth = 0,
            .wrapped = emitter,
            .function = Function.init(vm),
        };
    }

    // Emit returnu a disassemble pokud debug mod
    pub fn deinit(self: *Self) *Function {
        self.locals.deinit();
        self.emitOpCode(.op_return, self.parser.?.previous.location);

        const function = self.function;
        if (!self.reporter.had_error and debug.debugging) {
<<<<<<< HEAD
            debug.disBlock(self.currentBlock(), "code");
=======
            debug.disBlock(self.currentBlock(), if (function.name) |name| name else "script");
>>>>>>> fdb6ccb (Function preparation)
        }

        return function;
    }

    /// Kompilace
    pub fn compile(self: *Self, source: []const u8) ResultError!*Function {
        self.reporter.had_error = false;
        self.reporter.panic_mode = false;

        self.parser = Parser.init(self.allocator, self, self.vm, self.reporter);
        self.parser.?.parse(source);

        const func = self.deinit();
        if (self.reporter.had_error) return ResultError.compile;

        return func;
    }

    /// Získat aktuální blok
    pub fn currentBlock(self: *Self) *Block {
<<<<<<< HEAD
        return self.block.?;
=======
        return &self.function.block;
>>>>>>> fdb6ccb (Function preparation)
    }

    /// Zapsat instrukci do bloku
    pub fn emitOpCode(self: *Self, op_code: Block.OpCode, loc: Location) void {
        self.currentBlock().writeOp(op_code, loc);
<<<<<<< HEAD
    }

    pub fn emitByte(self: *Self, byte: u8, loc: Location) void {
        self.currentBlock().writeOpByte(byte, loc);
=======
>>>>>>> fdb6ccb (Function preparation)
    }

    /// Zapis hodnotu do bloku
    pub fn emitValue(self: *Self, val: Val, loc: Location) void {
        self.emitOpCodes(.op_value, self.makeValue(val), loc);
    }

    /// Zapsat instrukce do bloku
    pub fn emitOpCodes(self: *Self, op1: Block.OpCode, op2: u8, loc: Location) void {
        self.currentBlock().writeOp(op1, loc);
        self.currentBlock().writeOpByte(op2, loc);
    }

    /// Přidání hodnoty do aktuálního bloku
    pub fn makeValue(self: *Self, val: Val) u8 {
        const value = self.currentBlock().addValue(val);
<<<<<<< HEAD
=======
        if (value > 255) @panic("Stack overflow");

>>>>>>> fdb6ccb (Function preparation)
        return value;
    }
};
